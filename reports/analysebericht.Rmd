---
output: 
  bookdown::pdf_document2:
    keep_tex: false
    fig_caption: true
    latex_engine: pdflatex
    toc: false
    toc_depth: 2
    number_sections: true
quot-lang: de-CH
header-includes:
  - \usepackage[T1]{fontenc}
  - \usepackage[ngerman]{babel}
  - \usepackage[german=swiss]{csquotes}
  - \usepackage{floatrow}
  - \floatsetup[table]{capposition=top}
  - \floatsetup[figure]{capposition=top}
title: "Der Listenrangeffekt bei den Grossratswahlen in Basel-Stadt: Analysebericht"
subtitle: "Work in Progress (Version 0.1.8) -- aktuellste Version [[hier]{.ul}](https://www.dropbox.com/scl/fi/1qpggskxxumjpiexj2kwm/analysebericht.pdf?rlkey=baxspwclhphpl945nvj5nhmw6&st=zcmkrqta&dl=0) herunterladen"
thanks: "Der Code und die Daten der Analysen sind auf Github abgelegt ([[Link]{.ul}](https://github.com/marcstoeckli/grossratswahlen_bs)). Ich freue mich über Kommentare und Anregungen via kontakt@stoecklieconomics.ch. Einen herzlichen Dank für ihr Feedback gehen an Tamina Graber, Edibe Gölgeli, Michela Seggiani und Salome Bessenich."
author: "Marc Stöckli"
abstract: "In diesem Bericht untersuche ich den Einfluss des Listenrangs auf den Wahlerfolg bei den Grossratswahlen 2008 bis 2024 in Basel-Stadt. Meine Analysen zeigen, dass ein niedrigerer Listenrang (= weiter oben auf der Liste) zu einem besseren Wahlergebnis führt. Der Effekt tritt besonders bei der GLP, SP, SVP und der BastA! auf und variiert je nach Wahljahr und -kreis. Bei der SP stelle ich einen deutlichen Anstieg des Listenrangeffekts in den Wahljahren 2020 und 2024 fest. Die Ergebnisse zeigen, dass es aus Sicht der Frauenförderung ein effektives Instrument ist, die Frauen bei Listenwahlen zuerst aufzuführen. Für eine aktive Gleichstellungspolitik ist diese Trennung nach Geschlecht sinnvoll und sollte in der SP beibehalten werden. Hingegen kann es problematisch sein, Kandidierende alphabetisch aufzulisten."
date: "`r format(Sys.time(), '%d. %B %Y')`"
geometry: margin=1in
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(broom)
library(knitr)
library(margins)
library(kableExtra)
library(gridExtra)
library(cowplot)
library(bookdown)
load("../data/processed/data_final.RData")
load("../data/processed/data_final_all.RData")

get_legend <- function(myplot) {
  g <- ggplotGrob(myplot)
  legend <- g$grobs[which(sapply(g$grobs, function(x) x$name) == "guide-box")][[1]]
  return(legend)
}

add_stars <- function(p_value) {
  if (p_value < 0.01) {
    return("***")
  } else if (p_value < 0.05) {
    return("**")
  } else if (p_value < 0.1) {
    return("*")
  } else {
    return("")
  }
}

partyplot <- function(party_name, party_title, party_ncol,
                      party_model){
  data_final_all %>% 
    mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
           year = factor(year, levels = seq(2024, 2020, by = -2))) %>% 
    filter(party == party_name) %>% 
    mutate(outcome_pred = predict(lm(party_model, 
                                  data = .))) %>%
    ggplot(aes(x = list_place, y = rank)) +
    geom_point(aes(col = gender, shape = incumbent)) +
    geom_line(aes(x = list_place, y = outcome_pred, linetype = incumbent), 
              col = "blue", 
              alpha = 0.5) +
    scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                       labels = c("M" = "M", "F" = "F")) +
    scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                       labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
    scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                          labels = c("TRUE" = "Amtierend", 
                                     "FALSE" = "Nicht amtierend")) +
    scale_x_continuous(breaks = seq(1, 34, 4), limits = c(1, 35)) +
    scale_y_reverse(breaks = seq(1, 34, 8), limits = c(35, 1)) +
    facet_wrap(~ kreis + year, ncol = party_ncol) +
    labs(title = party_title, x = "Listenrang", y = "Wahlergebnisrang") +
    theme_minimal() +
    guides(color = guide_legend(title = "Geschlecht"),
           shape = guide_legend(title = "Amtierend"),
           linetype = guide_legend(title = "Regressionslinie")) +
    theme(legend.position = "bottom",
          legend.direction = "vertical",
          legend.box = "horizontal",
          legend.background = element_blank(),
          legend.title = element_text(size = 10, face = "bold"),
          legend.text = element_text(size = 9),
          legend.key.size = unit(0.5, "lines"),
          legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
          plot.title = element_text(size = 10))
}
```

```{r models, include=FALSE, paged.print=FALSE}
# Rang

## Alle Parteien
model_all <- lm("rank ~ party*incumbent + year + kreis + party*gender + party*list_place", data = data_final_all)

model_all_share <- lm("share_scale ~ party*incumbent + year + kreis + party*gender + party*list_place", data = data_final_all)

margins_model_all <- margins(model_all, 
                              variables = "list_place", 
                              at = list(party = model_all$xlevels$party)) %>% 
  summary() %>% 
  select(party, AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## SP gesamt
model_sp <- lm("rank ~ kreis*incumbent + year + kreis*gender + list_place", 
   data = data_final)

model_sp_share <- lm("share_scale ~ kreis*incumbent + year + kreis*gender + list_place", 
   data = data_final)

margins_sp <- margins(model_sp) %>% 
  summary() %>% 
  select(AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## SP nach Wahljahre
model_sp_years <- lm("rank ~ kreis*incumbent + kreis*gender + year*list_place", 
   data = data_final)

model_sp_years_share <- lm("share_scale ~ kreis*incumbent + kreis*gender + year*list_place", 
   data = data_final)

margins_sp_years <- margins(model_sp_years, variables = "list_place", 
                            at = list(year = model_sp_years$xlevels$year)) %>% 
  summary() %>% 
  select(year, AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## SP nach Wahlkreis (Basismodell)
model_sp_kreis <- lm("rank ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = data_final)

model_sp_kreis_share <- lm("share_scale ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = data_final)

margins_sp_kreis <- margins(model_sp_kreis, variables = "list_place", 
        at = list(kreis = model_sp_kreis$xlevels$kreis)) %>% 
  summary() %>% 
  select(kreis, AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## SP nach Geschlecht
model_sp_gender <- lm("rank ~ kreis*incumbent + year + gender*kreis*list_place", data = data_final)

model_sp_gender_share <- lm("share_scale ~ kreis*incumbent + year + gender*kreis*list_place", data = data_final)

margins_sp_gender <- margins(model_sp_gender, 
        variables = "list_place", 
        at = list(gender = model_sp_gender$xlevels$gender)) %>% 
  summary() %>% 
  select(gender, AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## SP nach veränderten Wahlzettel
model_sp_ownothers <- lm("rank ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

model_sp_ownothers_share <- lm("share_scale ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

model_sp_own <- lm("rank_own ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

model_sp_own_share <- lm("share_own_scale ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

model_sp_others <- lm("rank_others ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

model_sp_others_share <- lm("share_others_scale ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = subset(data_final_all, party == "SP"))

margins_sp_others <- margins(model_sp_others, variables = "list_place", 
        at = list(kreis = model_sp_others$xlevels$kreis)) %>% 
  summary() %>% 
  select(kreis, AME) %>% 
  mutate(AME = round(AME, 2)) %>% 
  deframe()

## Weiter erklärende Variablen
model_sp_weitere <- lm("rank ~ kreis*incumbent + year + kreis*gender + age + above + below + list_place", 
            data = data_final_all %>% filter(party == "SP"))

model_sp_weitere_share <- lm("share_scale ~ kreis*incumbent + year + kreis*gender + age + above + below + list_place", 
            data = data_final_all %>% filter(party == "SP"))

# Anteil

scale_factors <- data_final %>% 
  group_by(year, kreis) %>% 
  summarise(share_sd = sd(share),
            list_place_sd = sd(list_place)) %>% 
  mutate(scale_factor = share_sd/list_place_sd)
```

# Einführung {#sec_intro}

In diesem Bericht untersuche ich den Einfluss der Reihenfolge, in der die Kandidierenden bei den Grossratswahlen in Basel-Stadt auf der Liste aufgeführt werden auf den Wahlerfolg. Ich untersuche, ob ein niedrigerer Listenrang (d.h. als Kandidat:in weiter oben auf der Liste aufgeführt zu sein) zu mehr Stimmen im Vergleich zu den anderen Kandidierenden auf derselben Liste führt. Oder äquivalent: Ob ein *höherer* Listenrang (d.h. weiter *unten* auf der Liste aufgeführt zu sein) zu *weniger* Stimmen führt. Ein solcher \enquote{Listenrangeffekt} erscheint plausibel, da anzunehmen ist, dass Wählende beim Kumulieren oder Panaschieren \enquote{von unten her} streichen. Kandidierende auf den unteren Listenplätzen werden dadurch mechanisch öfter gestrichen als jene weiter oben.

Es gibt mehrere Hypothesen, wieso Wählende von unten her streichen. Einerseits können die Listenplätze die Präferenz der Partei widerspiegeln (wie es bei anderen Parteien durchaus üblich ist). Wenn Wählende dieser Präferenz folgen möchten, streichen sie daher die unteren Listenplätze, wenn sie kumulieren oder panaschieren. Andererseits ist es beim Kumulieren mehrerer Kandidierender einfacher, die erforderliche Anzahl an zu streichenden Personen als \enquote{Gruppe} von unten her zu streichen, bis genug Kandidierende entfernt wurden.

Widerspiegeln die Listenplätze die Präferenz der Partei, ist der Listenrangeffekt nicht zwingend problematisch (und aus Sicht der Partei gegebenenfalls sogar erwünscht). Für die Wählenden ist es jedoch nicht immer ersichtlich, ob die Reihenfolge der Kandidierenden wirklich eine Präferenz der Partei darstellt. Zahlreiche Parteien führen bei den Grossratswahlen beispielsweise die amtierenden Grossrät:innen auf den niedrigsten Listenrängen auf (siehe Tabelle \ref{tab:tab10} im Anhang), was jedoch nicht zwingend impliziert, dass auch die restlichen Ränge einer Präferenz folgen.

Wenn die Reihenfolge nicht die Präferenz der Partei widerspiegelt, ist der Listenrangeffekt in der Regel unerwünscht. Das Wahl- und Abstimmungsreglement der SP Basel-Stadt legt beispielsweise unter anderem fest, dass bei Listenwahlen die Kandidierenden in alphabetischer Reihenfolge aufzuführen sind. Dies führt dazu, dass Kandidierende mit Nachnamen hinten im Alphabet bei einem allfälligen Listenrangeffekt systematisch benachteiligt werden. Dieselbe Person würde zudem bei *jeder* Wahl benachteiligt werden, da sie aufgrund ihres Nachnamens immer einen schlechten Listenplatz hätte.

Für die Analysen in diesem Bericht untersuche ich die Daten der Grossratswahlen von Basel-Stadt der Jahre 2024, 2020, 2016, 2012 und 2008. Ich konzentriere mich dabei auf den Effekt des Listenrangs auf den Rang, den eine kandidierende Person in ihrem Wahlkreis auf ihrer Liste bei der Wahl erreicht hat (kurz \enquote{Wahlergebnisrang}). Wenn die gefundene Effektstärke 0 beträgt, hat der Listenrang keinen Einfluss auf den Wahlerfolg. Liegt die Effektstärke über 0, führt ein höherer Listenrang -- bei sonst gleichen Bedingungen -- im Durchschnitt zu einem schlechteren Wahlergebnisrang. Eine Effektstärke von 1 bedeutet, dass ein Platz weiter unten auf der Liste genau einen Rang schlechter im Wahlergebnis bedeutet. In diesem Bericht bezeichne ich eine Effektstärke ab 0.25 als hoch und ab 0.5 als sehr hoch.

Ich zeige Ergebnisse für alle Listen/Parteien, beschränke mich für vertiefte Analysen aber auf die SP. Als Erweiterung untersuche ich zusätzlich den Effekt des Listenrangs auf den Anteil der Stimmen einer kandidierenden Person an den gesamten Stimmen für ihre Liste in ihrem Wahlkreis (kurz \enquote{Stimmenanteil}).

Methodisch verwende ich multivariate Regressionsanalysen. Dies ermöglicht es mir, den Effekt des Listenrangs von anderen Effekten -- dem Geschlecht, dem Alter, dem Bisherigen-Status, etc. -- zu unterscheiden. Ziel ist es, den *kausalen* Effekt des Listenrangs auf den Wahlerfolg zu finden.

Zusammenfassend finde ich in meinen Analysen Folgendes:

-   **Bei fast allen Parteien** **finde ich einen Listenrangeffekt**. Der Effekt ist am stärksten ausgeprägt bei der GLP, SP, SVP und der BastA! (in dieser Reihenfolge). Einzig bei der LDP gibt es keine Hinweise darauf, dass der Listenrang relevant für den Wahlerfolg ist.

-   Über alle Wahljahre und -kreise hinweg gewinnt bei der SP ein:e Kandidat:in pro \enquote{besseren} Listenplatz -- bei sonst gleichen Bedingungen -- im Durchschnitt **`r margins_sp["list_place"]`** **Wahlergebnisränge** (siehe Kapitel \ref{subsec_basemodel}). Im Umkehrschluss *verliert* ein:e Kandidat:in pro \enquote{schlechteren} Listenplatz `r margins_sp["list_place"]` Wahlergebnisränge.

-   Der Listenrangeffekt hat **über die Jahre stark zugenommen** (siehe Kapitel \ref{subsec_years}). Während ich bei den Wahlen von 2008 noch keinen Effekt finden kann, finde ich (nicht signifikante) Effekte bei den Wahlen von 2012 (Effektstärke: `r margins_sp_years["2012"]`) und 2016 (Effektstärke: `r margins_sp_years["2016"]`). Bei der Grossratswahl von 2020 sowie 2024 finde ich statistisch signifikante und hohe Listenrangeffekte (**Effektstärke:** **`r margins_sp_years["2020"]` bzw. `r margins_sp_years["2024"]`**).

-   Innerhalb der SP gibt es **deutliche Unterschiede des Effekts über die Wahlkreise** (siehe Kapitel \ref{subsec_kreis}). Am stärksten ist der Listenrangeffekt in Grossbasel Ost (**Effektstärke:** **`r margins_sp_kreis["Grossbasel Ost"]`**) und dem Kleinbasel (**Effektstärke:** **`r margins_sp_kreis["Kleinbasel"]`**). Der Listenrangeffekt in Riehen ist zwar sehr hoch (**Effektstärke:** **`r margins_sp_kreis["Riehen"]`**), aber nicht statistisch signifikant, vermutlich aufgrund der kleinen Stichprobengrösse (Riehen ist mit deutlich weniger Sitzen im Grossen Rat vertreten). In Grossbasel West kann ich keinen eindeutigen Effekt finden, da sich die Richtung und Stärke des Effekts von 2008 bis 2024 beachtlich verändert. Bei dein Wahlen von 2020 und 2024 zeichnet sich grundsätzlich aber auch in Grossbasel West ein Listenrangeffekt ab.

-   Der Listenrangeffekt ist **für Frauen und Männer ähnlich stark ausgeprägt** (siehe Kapitel \ref{subsec_gender}). Für Frauen und Männer spielt es für den Wahlerfolg insofern gleichermassen eine Rolle, auf einem \enquote{guten} Listenplatz zu sein.

-   Werden nur die veränderten Wahlzettel betrachtet, so zeigt sich, dass der Listenrangeffekt **leicht stärker ausgeprägt ist bei den Stimmen von veränderten Wahlzetteln der SP-Liste** im Vergleich zu den Stimmen von anderen Listen (siehe Kapitel \ref{subsec_ownother}). Anders ausgedrückt: Das Kumulieren und Streichen auf der SP-Liste führt zu einem leicht stärkeren Listenrangeffekt als das Panaschieren von SP-Kandidierenden. In Bezug auf die Anzahl der Panaschierstimmen zeigt sich zudem, dass der Listenrang einen höheren Effekt bei den amtierenden Grossrät:innen im Vergleich zu den neuen Kandidierenden hat.

-   **Amtierende Grossrät:innen** schneiden deutlich besser ab als neue Kandidierende. Keinen statistisch signifikanten Effekt konnte ich hingegen für das **Alter** finden. Ebenso konnte ich keinen statistisch signifikanten Effekt finden, ob eine kandidierende Person auf der Liste **unter oder über einer amtierenden kandidierenden Person** aufgeführt ist (siehe Kapitel \ref{subsec_others}).

Basierend auf den Ergebnissen sehe ich folgende Handlungsempfehlungen:

-   Aus Sicht der Frauenförderung ist es ein effektives Instrument, die Frauen bei Listenwahlen zuerst aufzuführen. Die SP Basel-Stadt legt diese Regelung bereits jetzt schon in ihrem Wahl- und Abstimmungsreglement fest. **Um weiterhin eine aktive Gleichstellungspolitik zu betreiben, ist diese Regelung beizubehalten**.

-   Problematisch kann hingegen **eine alphabetische Auflistung der Kandidierenden** sein. Diese Regelung ist aktuell ebenfalls im Wahl- und Abstimmungsreglement der SP Basel-Stadt festgelegt. Dadurch werden Personen mit Namen hinten im Alphabet systematisch benachteiligt. Es empfiehlt sich zu prüfen, ob eine alternative Listenvergabe zielführender ist (beispielsweise das Auslosen der Listenplätze).

Der Rest dieses Berichts ist wie folgt aufgebaut. In Kapitel \ref{sec_data} beschreibe ich die Daten, die ich für die Analysen verwende. In Kapitel \ref{sec_model} beschreibe ich das statistische Modell, mit dem ich den Einfluss des Listenrangs auf den Wahlerfolg untersuche. In Kapitel \ref{sec_results} und \ref{sec_results_other} zeige ich die Ergebnisse, erst jene für die SP und anschliessend jene für die weiteren Parteien.

# Daten {#sec_data}

Ich analysiere die Daten der Grossratswahlen in Basel-Stadt der Jahre 2024, 2020, 2016, 2012 und 2008. Für die Jahre 2024 und 2020 kann ich hierfür auf das Datenportal \enquote{Open Government Data} (OGD) zurückgreifen, über welches die Daten bereits aufbereitet und in hoher Qualität verfügbar sind. Für die Jahre 2016, 2012 und 2008 habe ich die Daten aus den PDFs der Wahlresultate und -protokolle zusammengetragen. Da in diesen PDFs die Amtsinhaberschaft nicht erkennbar ist, habe ich zusätzlich die Datenbank der Ratsmitgliedschaften aus dem OGD verwendet, um die amtierenden Grossrät:innen zum Zeitpunkt der jeweiligen Wahl zu identifizieren.

Für die SP nutze ich die Daten aller Grossratswahlen von 2008 bis 2024. Für die restlichen Listen bzw. Parteien nutze ich lediglich die Daten der Wahlen von 2024 und 2020. Ich berücksichtige folgende Listen: BastA!, FDP, GLP, GRÜNE, Grünes Bündnis, LDP, Die Mitte/CVP und SVP. BastA! und GRÜNE sind in den Daten nur im Wahljahr 2024 vertreten, da 2020 die beiden Parteien noch als gemeinsame Liste \enquote{Grünes Bündnis} angetreten sind. Analog ist das Grüne Bündnis in den Daten nur 2020 vertreten. Die CVP hat zwischen den Wahljahren 2020 und 2024 ihren Namen zu \enquote{Die Mitte} geändert. Ich spreche einfachheitshalber in beiden Jahren von der Mitte. Alle weiteren Listen aus den Wahlen von 2024 und 2020 schliesse ich von der Analyse aus, da sie nicht vergleichbar sind.

Den Listenrang eine:r Kandidat:in bestimme ich anhand der letzten beiden Ziffern der Kandidierendennummer. Die Person mit der Nummer \enquote{0501} hat beispielsweise Listenrang 1, die Person mit der Nummer \enquote{0510} Listenrang 10. Da jede Kombination aus Wahljahr, Partei und Wahlkreis eigene Listenränge hat, kommt derselbe Listenrang mehrfach in den Daten vor (Listenrang 1 bei den Grossratswahlen von 2024 der SP in *Grossbasel Ost*, Listenrang 1 bei den Grossratswahlen von 2024 der SP im *Grossbasel West*, etc.).

Ein höherer Listenrang beutet grundsätzlich, dass eine Person weiter unten auf dem Wahlzettel erscheint. Allerdings wird die obere Hälfte der Kandidierenden auf der linken Seite des Wahlzettels aufgeführt, die untere Hälfte auf der rechten Seite. Personen mit einem Listenplatz in der Mitte können daher sowohl oben (rechts) als auch unten (links) auf dem Wahlzettel stehen.

Ich untersuche den Einfluss des Listenrangs auf zwei Zielgrössen: Erstens den Rang, den eine kandidierende Person auf ihrer Liste im Wahlkreis erreicht (\enquote{Wahlergebnisrang}). Zweitens den Anteil der Stimmen, die eine kandidierende Person im Vergleich zu den Gesamtstimmen ihrer Liste im Wahlkreis erhält (\enquote{Stimmenanteil}). Den Stimmenanteil berechne ich dabei ohne Zusatzstimmen, sodass die Summe der Stimmenanteile aller Kandidat:innen einer Liste in einem Wahlkreis genau 100% ergibt.[^1]

[^1]: Zusatzstimmen erhält eine Liste bei ungültigen Stimmen, gestrichenen Namen und leeren Linien.

Der Wahlergebnisrang und der Stimmenanteil eine:r Kandidat:in sind zwar hoch miteinander korreliert, dennoch kann der Einfluss des Listenrangs auf diese beiden Zielgrössen unterschiedlich sein. Welche Zielgrösse \enquote{korrekt} ist, hängt von der Perspektive ab. Der Effekt des Listenrangs auf den Stimmenanteil kann beispielsweise gering sein. Wenn die Anzahl Stimmen für die Kandidierenden jedoch nahe beieinander liegen, kann dies für die Wahrscheinlichkeit, gewählt zu werden, dennoch relevant sein. Da ich mich in dieser Analyse vorrangig für den Einfluss des Listenrangs auf die Wahlwahrscheinlichkeit interessiere, konzentriere ich mich auf den Wahlergebnisrang. Die Ergebnisse für den Stimmenanteil zeige ich im Anhang.

## Deskriptive Analyse

Abbildungen \ref{fig:fig1} und \ref{fig:fig2} zeigen den Zusammenhang zwischen dem Listenrang (X-Achse, d.h. von links nach rechts) und dem Wahlergebnisrang (Y-Achse, d.h. von unten nach oben) für die SP, jeweils separat für die Wahlkreise Kleinbasel, Grossbasel Ost, Grossbasel West und Riehen. Jeder Punkt ist eine kandidierende Person in dem jeweiligen Wahlkreis und -jahr. Die Abbildungen sind wie folgt zu lesen:

-   Je weiter *links* ein Punkt liegt, desto niedriger ist der Listenrang dieser Person, d.h. desto weiter oben befindet sie sich auf der Liste. Die Person am weitesten links hat mit Listenrang 1 den niedrigsten Listenrang und befindet sich somit auf der Liste zuoberst.

-   Je weiter *oben* ein Punkt liegt, desto niedriger ist der Wahlergebnisrang dieser Person, d.h. desto besser ist ihr Wahlergebnis. Die Person am weitesten oben in der Abbildung ist die Person mit dem besten Wahlergebnis (Wahlergebnisrang 1).

Frauen (blau) und Männer (grün) sind farblich hervorgehoben. Dabei zeigt sich die Regelung der SP, dass zuerst die Frauen und anschliessend die Männer auf der Liste aufgeführt werden. Ebenfalls hervorgehoben sind die amtierenden Grossrät:innen (Dreiecke) und die neuen Kandidierenden (Kreise). Die amtierenden Grossrät:innen weisen über alle Wahlkreise und Jahre die deutlich besseren Wahlergebnisse aus. Dieser Effekt ist wohlbekannt, da er bei jeder Grossratswahl so offensichtlich und stark ausgeprägt ist.

Ein (nicht zwingend kausaler) Listenrangeffekt zeigt sich in den Abbildungen dadurch, dass das Wahlergebnis im Durchschnitt schlechter ausfällt, je weiter rechts eine Person liegt. Die blauen Regressionslinien visualisiert diesen Zusammenhang. Eine Regressionslinie wird in jedem Wahlkreis und -jahr so durch die Punktewolke gezogen, dass sie die Summe der (quadrierten) vertikalen Abstände zu den Punkten minimiert. In jedem Wahlkreis und -jahr sind jeweils zwei Regressionslinien eingezeichnet, je einmal für die amtierenden Grossrät:innen (gestrichelte Linie) und die neuen Kandidierenden (durchgezogene Linie).

Beim Betrachten der Abbildungen und insbesondere der Regressionslinien lässt sich in mehreren Wahlkreisen ein Zusammenhang zwischen dem Listenrang und dem Wahlergebnisrang erkennen. Grundsätzlich gilt: Je steiler die Regressionslinie, desto stärker der Zusammenhang. Es zeigt sich, dass der Zusammenhang über die Jahre zugenommen hat und deutliche Unterschiede zwischen den Wahlkreisen bestehen. Besonders stark ist der Zusammenhang in den Jahren 2024 und 2020. 2008 war der Zusammenhang in den meisten Wahlkreisen hingegen noch weniger stark ausgeprägt (in Grossbasel West ist der Effekt teilweise sogar gegenteilig).

Aus diesem Zusammenhang kann jedoch noch kein kausaler Listenrangeffekt ableitet werden, da es noch weitere Effekte geben kann, die das Ergebnis verzerren können. Wenn es beispielsweise noch zusätzlich einen Geschlechtereffekt gibt, ist die Regressionslinie (die den Listenrangeffekt widerspiegelt) dadurch zu \enquote{steil}, weil die Linie bei den niedrigen Listenrängen durch die guten Wahlergebnisse der Frauen nach oben \enquote{gezerrt} wird. Mit einem statistischen Modell können diese weiteren Effekte \enquote{herausgerechnet} werden. Das von mir verwendete Modell wird in Kapitel 3 beschrieben.

Im Anhang zeige ich die Abbildung der Jahre 2024 und 2020 für die restlichen Parteien bzw. Listen (Abbildung \ref{fig:fig10} bis \ref{fig:fig15}). Bei den anderen Parteien zeigt sich ein noch deutlicherer Listenrangeffekt, insbesondere bei der GLP.

```{r fig1, fig.cap="Listen- und Wahlergebnisrang", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8.5, fig.align='center', fig.pos='H'}
data_final %>% 
  filter(kreis %in% c("Kleinbasel", "Grossbasel Ost")) %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         kreis = factor(kreis, levels = c("Kleinbasel", "Grossbasel Ost")),
         year = factor(year, levels = seq(2024, 2008, by = -4))) %>% 
  mutate(rank_pred = predict(lm(rank ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = rank)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = rank_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  scale_x_continuous(breaks = seq(1, 34, 4), limits = c(1, 35)) +
  scale_y_reverse(breaks = seq(1, 34, 8), limits = c(35, 1)) +
  facet_wrap(~ year + kreis, ncol = 2) +
  labs(x = "Listenrang", y = "Wahlergebnisrang") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

```{r fig2, fig.cap="Listen- und Wahlergebnisrang", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8.5, fig.align='center', fig.pos='H'}
data_final %>% 
  filter(kreis %in% c("Grossbasel West", "Riehen")) %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         kreis = factor(kreis, levels = c("Grossbasel West", "Riehen")),
         year = factor(year, levels = seq(2024, 2008, by = -4))) %>% 
  mutate(rank_pred = predict(lm(rank ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = rank)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = rank_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  scale_x_continuous(breaks = seq(1, 34, 4), limits = c(1, 35)) +
  scale_y_reverse(breaks = seq(1, 34, 8), limits = c(35, 1)) +
  facet_wrap(~ year + kreis, ncol = 2) +
  labs(x = "Listenrang", y = "Wahlergebnisrang") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

# Statistisches Modell {#sec_model}

Ich untersuche den Effekt des Listenrangs auf den Wahlergebnisrang bzw. den Stimmenanteil mittels einer multivariaten Regressionsanalyse. Konkret schätze ich Varianten des folgenden linearen Modells:

$$
y_{it} = \beta_0 + \beta_1 Geschlecht_{it} + \beta_2 Bisher_{it} + \beta_3 Wahlkreis_{it} + \beta_4 Rang_{it} + Jahr_t + \boldsymbol{X} \boldsymbol{\beta} + \varepsilon_{it}
$$

Die Variablen sind wie folgt definiert:

-   $y_{it}$: Wahlergebnisrang bzw. Stimmenanteil von Kandidat:in $i$ im Wahljahr $t$

-   $Geschlecht_{it}$: Geschlecht von Kandidat:in $i$ im Wahljahr $t$ (Dummy-Variable mit Basiskategorie = Frau)

-   $Bisher_{it}$: Bisherigen-Status von Kandidat:in $i$ im Wahljahr $t$ (Dummy-Variable mit Basiskategorie = Nein)

-   $Wahlkreis_{it}$: Wahlkreis von Kandidat:in $i$ im Wahljahr $t$ (Faktor-Variable mit Basiskategorie = Grossbasel Ost)

-   $Rang_{it}$: Listenrang von Kandidat:in $i$ im Wahljahr $t$

-   $Jahr_t$: Wahljahr (Faktor-Variable mit Basiskategorie = 2008)

-   $\boldsymbol{X}$: Zusätzliche Kontrollvariablen

-   $\varepsilon_{it}$: Fehlerterm von Kandidat:in $i$ in Wahljahr $t$

$\beta_0$, $\beta_1$ etc. sind die Koeffizienten und werden mit Ordinary Least Squares (OLS) geschätzt. $\boldsymbol{X}$ sind zusätzliche Kontrollvariablen, die sich je nach Modellvariante unterscheiden. Besonderes Interesse besteht an $\beta_4$, dem Koeffizienten des Listenrangs. Ist $\beta_4 > 0$, führt ein höherer Listenrang zu einem höheren Wahlergebnisrang. Anders ausgedrückt: Je \enquote{schlechter} der Listenplatz, desto schlechter das Wahlergebnis -- bei sonst gleichen Bedingungen. \enquote{Bei sonst gleichen Bedingungen} bedeutet, dass alle anderen Variablen unverändert bleiben und nur der Listenrang um eine Einheit erhöht wird.

Ziel der Analyse ist es, $\hat{\beta}_4$ (der geschätzte Wert von $\beta_4$) *kausal* interpretieren zu können. Eine zentrale Bedingung hierfür ist, dass $Rang_{it}$ und $\varepsilon_{it}$ unkorreliert sind. Eine Korrelation würde unter anderem entstehen, wenn es Variablen gibt, die mit $Rang_{it}$ korreliert sind und *zusätzlich* einen Effekt auf $y_{it}$ haben. Solche Variablen müssen entsprechend in das Modell als Kontrollvariablen aufgenommen werden. Dies ist beispielsweise der Fall beim Geschlecht, da der Listenrang bei einigen Parteien per Konstruktion mit dem Geschlecht korreliert ist. Ebenso ist dies er Fall beim Bisherigen-Status, da bei einigen Parteien die amtierenden Grossrät:innen zuerst aufgelistet werden. Der Bisherigen-Status ist aber auch bei der SP notwendigerweise als Kontrollvariable aufzunehmen, da -- wenn es einen Listenrangeffekt gibt -- Kandidat:innen auf \enquote{guten} Listenplätzen über die Zeit im Grossen Rat überrepräsentiert sein können.

Für die kausale Interpretation von $\hat{\beta}_4$ hilft es, dass bei der SP und anderen Parteien innerhalb der Geschlechter die Kandidat:innen alphabetisch auf der Liste aufgeführt werden. Wird auf das Geschlecht und den Bisherigen-Status kontrolliert, ist es durch die alphabetische Vergabe unwahrscheinlich, dass der Listenrang mit weiteren Variablen korreliert ist, die einen Effekt auf $y_{it}$ haben. Denn der Listenrang widerspiegelt in diesem Fall weder die Präferenz der Partei noch die Eignung oder Bekanntheit der Kandidierenden.

# Ergebnisse für die SP {#sec_results}

## Basismodell {#subsec_basemodel}

Im Basismodell nehme ich als zusätzliche Kontrollvariablen $\boldsymbol{X}$ die Interaktionen aus Geschlecht und Wahlkreis ($Geschlecht \times Wahlkreis_{it}$) sowie aus Bisherigen-Status und Wahlkreis ($Bisher \times Wahlkreis_{it}$) auf. Diese Interaktionen erlauben es mir, Unterschiede im Geschlechtereffekt bzw. dem Effekt der Amtsinhaberschaft über die Wahlkreise abzubilden.

Tabelle \ref{tab:tab1} zeigt die geschätzten marginalen Listenrangeffekte. Ich finde einen signifikanten Effekt des Listenrangs: Im Durchschnitt verliert ein:e Kandidierende:r pro Listenplatz weiter unten `r margins_sp["list_place"]` Wahlergebnisränge. Weiter finde ich einen signifikanten Effekt der Amtsinhaberschaft. Amtierende Grossrät:innen haben im Durchschnitt einen `r abs(margins_sp["incumbent"])` tieferen Wahlergebnisrang. Keinen Effekt kann ich hingegen für das Geschlecht finden. Dies deutet darauf hin, dass der Unterschied im Wahlerfolg zwischen Frauen und Männern durch die Unterschiede in den Listenrängen erklärt werden kann.

```{r tab1, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp

margins(model) %>%
  tidy() %>%
  mutate(id = factor(term, levels = c("genderM", "incumbent", "kreisGrossbasel West", "kreisKleinbasel", "kreisRiehen", "year2024", "year2020", "year2016", "year2012", "list_place"))) %>% 
  arrange(id) %>%
  mutate(`Variable` = case_when(term == "genderM" ~ "Geschlecht = Mann",
                                term == "incumbent" ~ "Bisher = Ja",
                                term == "kreisGrossbasel West" ~ "Grossbasel West",
                                term == "kreisKleinbasel" ~ "Kleinbasel",
                                term == "kreisRiehen" ~ "Riehen",
                                term == "list_place" ~ "Listenrang",
                                term == "year2012" ~ "Jahr = 2012",
                                term == "year2016" ~ "Jahr = 2016",
                                term == "year2020" ~ "Jahr = 2020",
                                term == "year2024" ~ "Jahr = 2024",
                                TRUE ~ term),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Variable`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Marginale Effekte", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "4.75cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

## Heterogenität über die Wahljahre {#subsec_years}

Um zu untersuchen, ob sich der Effekt über die Jahre verändert hat, verwende ich das Basismodell und nehme zusätzlich eine Interaktion aus dem Listenrang und dem Wahljahr ($Rang \times Jahr_{it}$) auf. Dadurch kann ich für jedes Wahljahr einen separaten marginalen Effekt schätzen. Die Ergebnisse in Tabelle \ref{tab:tab2} zeigen, dass in den Jahren 2008, 2012 und 2016 der Effekt noch nicht statistisch signifikant war. 2020 und 2024 finde ich jedoch hohe Listenrangeffekte (Effektstärke `r margins_sp_years["2020"]` bzw. `r margins_sp_years["2024"]`).

```{r tab2, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_years

margins(model, 
        variables = "list_place", 
        at = list(year = model$xlevels$year)) %>% 
  tidy() %>%
  mutate(id = factor(`at.value`, levels = c("2024", "2020", "2016", "2012"))) %>% 
  arrange(id) %>%
  mutate(`Jahr` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Jahr`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahljahren", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

## Heterogenität über die Wahlkreise {#subsec_kreis}

Analog untersuche ich, ob sich der Effekt über die Wahlkreise unterscheidet. Hierfür verwende ich das Basismodell und nehme zusätzlich eine Interaktion aus dem Listenrang und dem Wahlkreis ($Rang \times Wahlkreis_{it}$) auf. Die Ergebnisse in Tabelle \ref{tab:tab3} zeigen, dass es deutliche Unterschiede gibt: Während ich in Grossbasel Ost und dem Kleinbasel statistisch signifikante Effekte finde (Effektstärke: `r margins_sp_kreis["Grossbasel Ost"]` bzw. `r margins_sp_kreis["Kleinbasel"]`), deutet das Ergebnis in Grossbasel West (Effektstärke: `r margins_sp_kreis["Grossbasel West"]`) auf keinen Listenplatzeffekt hin. Der Effekt ist in Riehen zwar am grössten (Effektstärke: `r margins_sp_kreis["Riehen"]`) jedoch nicht statistisch signifikant. Dies liegt vermutlich daran, dass Riehen deutlich weniger Sitze im Grossen Rat hat und die Stichprobengrösse entsprechend kleiner ausfällt (die statistische Signifikanz ist stark durch die Stichprobengrösse beeinflusst).

```{r tab3, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_kreis

margins(model, 
        variables = "list_place", 
        at = list(kreis = model$xlevels$kreis)) %>% 
  tidy() %>%
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahlkreisen", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

## Heterogenität über Frauen und Männer {#subsec_gender}

Weiter untersuche ich, ob der Listenrangeffekt unterschiedlich stark für Frauen und Männer ausgeprägt ist. Wiederum verwende ich hierfür das Basismodell und nehme zusätzlich Interaktionen aus dem Geschlecht, Wahlkreis und Listenplatz ($Geschlecht \times Rang \times Wahlkreis_{it}$), Geschlecht und Rang ($Geschlecht \times Rang_{it}$) sowie Rang und Wahlkreis ($Rang \times Wahlkreis_{it}$) auf. Diese umfangreichen Interaktionen erlauben es mir, Unterschiede im Effekt über jede Kombination aus Geschlecht und Wahlkreis abzubilden (Frauen im Kleinbasel vs. Männer im Kleinbasel, Frauen in Riehen vs. Männer in Riehen, etc.). Anders ausgedrückt bedeuten diese Interaktionen, dass ich im Modell annehme, dass es i.) in jedem Wahlkreis einen unterschiedlichen Effekt gibt, i.) Frauen und Männer unterschiedliche Effekte haben und iii.) der unterschiedliche Effekt von Frauen und Männern in jedem Wahlkreis unterschiedlich ist.

Ich finde sowohl für Frauen als auch Männer einen statistisch signifikanten Listenrangeffekt (Effektstärke `r margins_sp_gender["F"]` bzw. `r margins_sp_gender["M"]`), siehe Tabelle \ref{tab:tab4}. Der Effekt ist für Frauen und Männer äusserst ähnlich. Innerhalb der Frauen sowie innerhalb der Männer spielt es für den Wahlerfolg insofern gleichermassen eine Rolle, auf einem \enquote{guten} Listenplatz zu sein.

```{r tab4, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_gender

margins(model, 
        variables = "list_place", 
        at = list(gender = model$xlevels$gender)) %>% 
  tidy() %>%
  mutate(`Geschlecht` = case_when(`at.value` == "M" ~ "Mann",
                                  `at.value` == "F" ~ "Frau"),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Geschlecht`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Geschlecht", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

## Heterogenität über SP- und Panaschierstimmen {#subsec_ownother}

Da von den unveränderten Wahlzetteln alle Kandidierende einer Liste in einem Wahlkreis gleich viele Stimmen erhalten, sind für den Wahlergebnisrang ausschliesslich die veränderten Wahlzettel (sowie die ungültigen Stimmen) relevant. Wahlzettel können verändert werden, indem Kandidierende auf der eigenen Liste kumuliert, gestrichen oder auf einer anderen Liste panaschiert werden.

Ich untersuche, ob sich der Listenrangeffekt der SP-Stimmen von jenem der Panaschierstimmen unterscheidet. Hierfür konstruiere ich die beiden alternativen Listenränge $Rang_{it}^{SP}$ und $Rang_{it}^{-SP}$. $Rang_{it}^{SP}$ ist der Listenrang der Kandidat:in $i$ in Wahljahr $t$, wenn ausschliesslich die Stimmen der veränderten SP-Wahlzettel berücksichtigt werden. Einen tiefen $Rang_{it}^{SP}$ erreicht ein:e Kandidat:in, indem er oder sie häufig kumuliert bzw. selten gestrichen wird. Analog dazu berücksichtige ich für $Rang_{it}^{-SP}$ ausschliesslich die Panaschierstimmen, d.h. die Stimmen, die ein:e Kandidat:in von den anderen Listen erhalten hat.

Ich nehmen wiederum die Interaktion $Rang \times Wahlkreis_{it}$ in das Basismodell auf, um Unterschiede über die Wahlkreise abbilden zu können. Ich schätze anschliessend das Modell separat mit $Rang_{it}$, $Rang_{it}^{SP}$ bzw. $Rang_{it}^{-SP}$ als abhängige Variable. Ich verwende dabei ausschliesslich Daten der Wahljahre 2024 und 2020, da ich nur für diese beiden Jahren zwischen SP- und Panaschierstimmen unterscheiden kann.

Die drei Tabellen unten zeigen die Resultate für $Rang_{it}$ (Tabelle \ref{tab:tab5}), $Rang_{it}^{SP}$ (Tabelle \ref{tab:tab6}) und $Rang_{it}^{-SP}$ (Tabelle \ref{tab:tab7}). Die Ergebnisse für $Rang_{it}$ und $Rang_{it}^{SP}$ sind relativ ähnlich. Interessant ist jedoch, dass ich in zwei Wahlkreisen auch für $Rang_{it}^{-SP}$ statistisch signifikante -- und vor allem hohe -- Effekte finde (Grossbasel West: `r margins_sp_others["Grossbasel West"]`, Kleinbasel: `r margins_sp_others["Kleinbasel"]`). Dies deutet darauf hin, dass Wähler:innen selbst beim Panaschieren -- bei sonst gleichen Bedingungen -- Kandidat:innen mit niedrigem Listenrang bevorzugen.

Eine visuelle Betrachtung der Daten bestätigt diese Resultate. Abbildungen \ref{fig:fig3} und \ref{fig:fig4} zeigen den Listenrang auf der X-Achse und die Anzahl SP-Stimmen (Abbildung \ref{fig:fig3}) bzw. Panaschierstimmen (Abbildung \ref{fig:fig4}) auf der Y-Achse.[^2] Bei den Panaschierstimmen fällt auf, dass der Listenrangeffekt auf die Anzahl Stimmen (approximiert durch die Regressionslinie) bei den Amtierenden deutlich stärker ausgeprägt ist als bei den Neuen. Bei den neuen Kandidierenden ist die Regressionslinie deutlich flacher, doch reichen schon kleine Unterschiede in der Anzahl der Stimmen aus, um einen Effekt auf den Wahlergebnis*rang* zu haben.[^3] Denn um einen besseren Wahlergebnisrang als eine andere kandidierende Person zu erreichen, genügt schon eine einzelne Stimme mehr (es kommt regelmässig vor, dass ein:e Kandidat:in mit einem Vorsprung von nur wenigen Stimmen gewählt wird bzw. nachrückt).

[^2]: Die Achsenabschnitte der X- und Y-Achse variieren in den Abbildungen je nach Wahlkreis und -jahr, da die Anzahl der Sitze im Grossen Rat pro Wahlkreis unterschiedlich ist und die Stimmenzahl für die SP zwischen den Jahren variiert.

[^3]: Die entsprechenden Abbildungen mit dem SP- bzw. Panaschierstimmenrang auf der Y-Achse befindet sich im Anhang (Abbildungen \ref{fig:fig5} und \ref{fig:fig6}).

```{r tab5, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_ownothers, variables = "list_place", 
        at = list(kreis = model_sp_ownothers$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

```{r tab6, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_own, variables = "list_place", 
        at = list(kreis = model_sp_own$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs der SP-Stimmen nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

```{r tab7, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_others, variables = "list_place", 
        at = list(kreis = model_sp_others$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs der Panaschierstimmen nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

Im Anhang Abbildung \ref{fig:fig7} untersuche ich die Stimmen der veränderten SP-Wahlzettel noch vertiefter. Mit den verfügbaren Daten ist es zwar nicht möglich herauszufinden, wie häufig ein:e Kandidat:in kumuliert oder gestrichen wurde. Es ist jedoch möglich herauszufinden, ob ein:e Kandidat:in *insgesamt* mehr Stimmen durch Kumulationen erhalten als dass er oder sie durch Streichungen verloren hat. Hierfür zeichne ich in Abbildung \ref{fig:fig7} die Anzahl der veränderten SP-Wahlzettel als rote, horizontale Linie ein. Wäre ein veränderter Wahlzettel *nicht* verändert worden, würden alle Kandidierenden genau eine Stimme pro Wahlzettel erhalten. Das bedeutet, dass wenn ein:e Kandidat:in exakt so viele Stimmen durch Kumulationen gewonnen wie er oder sie durch Streichungen verloren hat, er oder sie exakt auf der roten Linie liegt. Kandidierende über der roten Linie wurden daher insgesamt häufiger kumuliert als gestrichen, Kandidierende darunter häufiger gestrichen als kumuliert.

Mit einer Ausnahme in Riehen 2020 sind es ausschliesslich amtierende Grossrät:innen, die mehr kumuliert als gestrichen wurden. Auffallend ist jedoch, dass bei Weitem nicht in allen Wahlkreisen *alle* amtierenden Grossrät:innen mehr kumuliert als gestrichen wurden.

```{r fig3, fig.cap="Listenrang und SP-Stimmen", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8.5, fig.align='center', fig.pos='H'}
data_final_all %>% 
  filter(party == "SP") %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         year = factor(year, levels = c(2024, 2020))) %>% 
  mutate(votes_by_others_pred = predict(lm(votes_by_own ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = votes_by_own)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = votes_by_others_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  facet_wrap(~ kreis + year, ncol = 2, scale = "free") +
  labs(x = "Listenrang", y = "SP-Stimmen") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

```{r fig4, fig.cap="Listenrang und Panaschierstimmen", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8.5, fig.align='center', fig.pos='H'}
data_final_all %>% 
  filter(party == "SP") %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         year = factor(year, levels = c(2024, 2020))) %>% 
  mutate(votes_by_others_pred = predict(lm(votes_by_others ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = votes_by_others)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = votes_by_others_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  facet_wrap(~ kreis + year, ncol = 2, scale = "free") +
  labs(x = "Listenrang", y = "Panaschierstimmen") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

## Weitere erklärende Variablen {#subsec_others}

Ich untersuche, ob auch weitere Variablen eine Effekt auf den Wahlerfolg haben. Ich verwende das Basismodell und nehme zusätzlich das Alter der kandidierenden Person auf sowie je eine Dummy-Variable, die angibt, ob ein:e neue:r Kandidat:in einen Listenplatz oberhalb oder unterhalb einer amtierenden kandidierenden Person hat. Mit dem Alter untersuche ich, ob das Alter einen Einfluss auf den Wahlerfolg hat. Mit den beiden Dummy-Variablen untersuche ich, ob es eine Rolle spielt, ob sich ein:e neue:r Kandidat:in auf dem Wahlzettel in unmittelbarer Nähe einer amtierenden Person befindet (und dadurch häufiger gestrichen wird, wenn die amtierende Person kumuliert wird).

Die Ergebnisse in Tabelle \ref{tab:tab8} zeigen, dass weder das Alter noch die Nähe zu einer amtierenden Person einen statistisch signifikanten Effekt auf den Wahlergebnisrang haben. Ich finde insofern keine eindeutigen Hinweise darauf, dass jüngere oder ältere Kandidierende bessere Wahlergebnisse haben. Ebenso finde ich keine Hinweise darauf, dass es für den Wahlerfolg eine Rolle spielt, ob sich ein:e neue:r Kandidat:in auf dem Wahlzettel in der unmittelbaren Nähe einer amtierenden Person befindet.

```{r tab8, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_weitere

margins(model) %>%
  tidy() %>%
  mutate(id = factor(term, levels = c("genderM", "age", "incumbent", "above", "below", "kreisGrossbasel West", "kreisKleinbasel", "kreisRiehen", "year2024", "list_place"))) %>% 
  arrange(id) %>% 
  mutate(`Variable` = case_when(term == "genderM" ~ "Geschlecht = Mann",
                                term == "incumbent" ~ "Bisher = Ja",
                                term == "kreisGrossbasel West" ~ "Grossbasel West",
                                term == "kreisKleinbasel" ~ "Kleinbasel",
                                term == "kreisRiehen" ~ "Riehen",
                                term == "list_place" ~ "Listenrang",
                                term == "year2024" ~ "Jahr = 2024",
                                term == "above" ~ "Oberhalb Bisher = Ja",
                                term == "below" ~ "Unterhalb Bisher = Ja",
                                term == "age" ~ "Alter",
                                TRUE ~ term),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Variable`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte weiterer erklärender Variablen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "4.75cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

# Ergebnisse für weitere Parteien {#sec_results_other}

Für die Wahljahre 2024 und 2020 untersuche ich zusätzlich den Listenrangeffekt für die BastA!, FDP, GLP, GRÜNE, Grünes Bündnis, LDP, Die Mitte, SP und SVP. Ich verwende erneut das Basismodell und nehme zusätzlich eine Variable für die Partei der kandidierenden Person ($Partei_{it}$) sowie Interaktionen aus der Partei mit dem Bisherigen-Status ($Partei \times Bisher_{it}$), dem Geschlecht ($Partei \times Geschlecht_{it}$) und dem Listenrang ($Partei \times Rang_{it}$) auf.

Die Ergebnisse in Tabelle \ref{tab:tab9} zeigen, dass der Listenrangeffekt bei fast allen Parteien vorkommt. Einzig bei der LDP finde ich keine statistisch signifikanten Effekte. Der Effekt ist am grössten bei der GLP (Effektstärke: `r margins_model_all["GLP"]`), der SP (Effektstärke: `r margins_model_all["SP"]`), der SVP (Effektstärke: `r margins_model_all["SVP"]`) und der BastA! (Effektstärke: `r margins_model_all["BastA"]`). Der Listenrangeffekt des Grünen Bündnisses -- das als Liste nur in den Daten von 2020 vorkommt -- ist vermutlich ebenfalls stark durch die BastA! beeinflusst.

Der Effekt für die SP ist in dieser Tabelle grösser als im Basismodell (siehe Tabelle \ref{tab:tab1}), weil ausschliesslich die Wahljahre 2024 und 2020 berücksichtigt werden. Wie ich in Tabelle \ref{tab:tab2} gezeigt habe, ist in diesen beiden Jahren der Listenrangeffekt besonders ausgeprägt.

```{r tab9, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_all

margins(model, 
        variables = "list_place", 
        at = list(party = model$xlevels$party)) %>%
  tidy() %>%
  arrange(desc(estimate)) %>% 
  mutate(`Wahlkreis` = case_when(`at.value` == "BastA" ~ "BastA!",
                                 `at.value` == "FDP" ~ "FDP",
                                 `at.value` == "GB" ~ "Grünes Bündnis",
                                 `at.value` == "GLP" ~ "GLP",
                                 `at.value` == "GRÜNE" ~ "GRÜNE",
                                 `at.value` == "LDP" ~ "LDP",
                                 `at.value` == "Mitte" ~ "Die Mitte",
                                 `at.value` == "SP" ~ "SP",
                                 `at.value` == "SVP" ~ "SVP"),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekt nach Parteien", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Wahlergebnisrang" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

\newpage

# Anhang {#sec_appendix}

## Deskriptive Analyse für SP- und Panaschierstimmen

```{r fig5, fig.cap="Listenrang und SP-Stimmenrang", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
data_final_all %>% 
  filter(party == "SP") %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         year = factor(year, levels = c(2024, 2020))) %>% 
  mutate(rank_own_pred = predict(lm(rank_own ~ kreis*incumbent*year*list_place, 
                                    data = .))) %>%
  ggplot(aes(x = list_place, y = rank_own)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = rank_own_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  scale_x_continuous(breaks = seq(1, 34, 4), limits = c(1, 35)) +
  scale_y_reverse(breaks = seq(1, 34, 8), limits = c(35, 1)) +
  facet_wrap(~ kreis + year, ncol = 2, scale = "free") +
  labs(x = "Listenrang", y = "SP-Stimmenrang") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

```{r fig6, fig.cap="Listenrang und Panaschierstimmenrang", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
data_final_all %>% 
  filter(party == "SP") %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         year = factor(year, levels = c(2024, 2020))) %>% 
  mutate(rank_others_pred = predict(lm(rank_others ~ kreis*incumbent*year*list_place, 
                                       data = .))) %>%
  ggplot(aes(x = list_place, y = rank_others)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = rank_others_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  scale_x_continuous(breaks = seq(1, 34, 4), limits = c(1, 35)) +
  scale_y_reverse(breaks = seq(1, 34, 8), limits = c(35, 1)) +
  facet_wrap(~ kreis + year, ncol = 2, scale = "free") +
  labs(x = "Listenrang", y = "Panaschierstimmenrang") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

```{r fig7, fig.cap="Listenrang und SP-Stimmen", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
data_final_all %>% 
  filter(party == "SP") %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         year = factor(year, levels = c(2024, 2020))) %>% 
  ggplot(aes(x = list_place, y = votes_by_own)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_hline(aes(yintercept = ballot_kreis_list_changed), col = "red") +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  facet_wrap(~ kreis + year, ncol = 2, scale = "free") +
  labs(x = "Listenrang", y = "SP-Stimmen") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

## Deskriptive Analyse für den Stimmenanteil

```{r fig8, fig.cap="Listenrang und Stimmenanteil", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
data_final %>% 
  filter(kreis %in% c("Kleinbasel", "Grossbasel Ost")) %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         kreis = factor(kreis, levels = c("Kleinbasel", "Grossbasel Ost")),
         year = factor(year, levels = seq(2024, 2008, by = -4))) %>% 
  mutate(share_pred = predict(lm(share ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = share)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = share_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  facet_wrap(~ year + kreis, ncol = 2, scales = "free") +
  labs(x = "Listenrang", y = "Stimmenanteil") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

```{r fig9, fig.cap="Listenrang und Stimmenanteil", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
data_final %>% 
  filter(kreis %in% c("Grossbasel West", "Riehen")) %>% 
  mutate(incumbent = factor(incumbent, levels = c(TRUE, FALSE)),
         kreis = factor(kreis, levels = c("Grossbasel West", "Riehen")),
         year = factor(year, levels = seq(2024, 2008, by = -4))) %>% 
  mutate(share_pred = predict(lm(share ~ kreis*incumbent*year*list_place, 
                                data = .))) %>%
  ggplot(aes(x = list_place, y = share)) +
  geom_point(aes(col = gender, shape = incumbent)) +
  geom_line(aes(x = list_place, y = share_pred, linetype = incumbent), 
            col = "blue", alpha = 0.5) +
  scale_color_manual(values = c("M" = "#72cb8c", "F" = "#66a3c2"),
                     labels = c("M" = "M", "F" = "F")) +
  scale_shape_manual(values = c("TRUE" = 17, "FALSE" = 16),
                     labels = c("TRUE" = "Ja", "FALSE" = "Nein")) +
  scale_linetype_manual(values = c("TRUE" = 4, "FALSE" = 1),
                        labels = c("TRUE" = "Amtierend", "FALSE" = "Nicht amtierend")) +
  facet_wrap(~ year + kreis, ncol = 2, scales = "free") +
  labs(x = "Listenrang", y = "Stimmenanteil") +
  theme_minimal() +
  guides(color = guide_legend(title = "Geschlecht"),
         shape = guide_legend(title = "Amtierend"),
         linetype = guide_legend(title = "Regressionslinie")) +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.box = "horizontal",
        legend.background = element_blank(),
        legend.title = element_text(size = 10, face = "bold"),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5, "lines"),
        legend.margin = margin(t = 2, r = 2, b = 2, l = 2),
        plot.title = element_text(size = 10))
```

## Deskriptive Analyse für andere Parteien

```{r fig10, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
plot_gb <- partyplot(party_name = "GB", 
                     party_title = "Grünes Bündnis", 
                     party_ncol = 1,
                     party_model = "rank ~ incumbent*kreis*list_place")

plot_gruene <- partyplot(party_name = "GRÜNE", 
                         party_title = "GRÜNE", 
                         party_ncol = 1,
                         party_model = "rank ~ incumbent*kreis*list_place")

plot_basta <- partyplot(party_name = "BastA", 
                        party_title = "BastA!", party_ncol = 1,
                        party_model = "rank ~ incumbent*kreis*list_place")

plots <- list(plot_gb, plot_gruene, plot_basta)

plot_nolegend <- lapply(plots, function(x) x + theme(legend.position = "none"))
plot_final <- plot_grid(plotlist = plot_nolegend, ncol = 3, align = "v")
plot_grid(plot_final, get_legend(plots[[1]]), ncol = 1, rel_heights = c(1, 0.1))
```

```{r fig11, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
partyplot(party_name = "GLP", 
          party_title = "GLP", 
          party_ncol = 2, 
          party_model = "rank ~ incumbent*year*kreis*list_place")
```

```{r fig12, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
partyplot(party_name = "FDP", 
          party_title = "FDP", 
          party_ncol = 2, 
          party_model = "rank ~ incumbent*year*kreis*list_place")
```

```{r fig13, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
partyplot(party_name = "LDP", 
          party_title = "LDP", 
          party_ncol = 2, 
          party_model = "rank ~ incumbent*year*kreis*list_place")
```

```{r fig14, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
partyplot(party_name = "Mitte", 
          party_title = "Die Mitte", 
          party_ncol = 2, 
          party_model = "rank ~ incumbent*year*kreis*list_place")
```

```{r fig15, fig.cap="Listen- und Wahlergebnisrang -- Andere Parteien", echo=FALSE, message=FALSE, warning=FALSE, fig.width=6, fig.height=8, fig.align='center', fig.pos='H'}
partyplot(party_name = "SVP", 
          party_title = "SVP", 
          party_ncol = 2, 
          party_model = "rank ~ incumbent*year*kreis*list_place")
```

## Listenplatz-Regelungen

Bei den Grossratswahlen hat fast jede Partei bzw. Liste ihre eigene Regelung, wie die Listenplätze vergeben werden. In Tabelle \ref{tab:tab10} zeige ich die Regelungen für die Parteien in den Wahljahren 2024 und 2020 (für die SP zudem jene der Jahre 2016, 2012 und 2008). Die Spalte \enquote{Bisherige zuerst} gibt an, ob bei einer Partei die amtierenden Grossrät:innen an erster Stelle stehen, \enquote{Frauen zuerst} ob Frauen zuerst aufgelistet werden und \enquote{Alphabetisch} ob die Liste alphabetisch sortiert ist. Die Angaben in der Klammer geben an, innerhalb welcher Untergruppe die entsprechende Regelung zur Anwendung kommt. Die FDP hat 2020 beispielsweise die Frauen zuerst aufgelistet, dabei innerhalb der Frauen und Männer jeweils die amtierenden Grossrät:innen zuerst. Innerhalb dieser Gruppen -- amtierende Frauen, amtierende Männer, nicht-amtierende Frauen, nicht-amtierende Männer -- wurden die Kandidierenden schliesslich alphabetisch sortiert.

Tabelle \ref{tab:tab10} zeigt, dass die SP die einzige Partei ist, bei der die amtierenden Grossrät:innen nicht an erster Stelle stehen. Ebenso zeigt sich, dass ausser bei der SP im Jahr 2008 sowie der GLP die Listen bei allen Parteien in irgendeiner Form alphabetisch sortiert sind.[^4][^5] Auffällig ist, dass nicht alle linken Parteien die Frauen zuerst auflisten (die GRÜNEN weichen davon ab) und dass es mit der FDP im Jahr 2020 auch eine bürgerliche Partei gab, die die Frauen zuerst aufgelistet hat. Die GLP reiht in mehreren Wahlkreisen die Frauen und Männer zudem abwechselnd.

[^4]: Bei der SVP ist der *Wahlzettel* von oben nach unten alphabetisch sortiert, nicht der Listenrang per se. In anderen Worten, bei beispielsweise 35 Listenplätzen in einem Wahlkreis werden die Listenplätze 1 bis 17 separat von den Listenplätzen 18 bis 35 alphabetisch sortiert.

[^5]: Die Mitte listet zwar die amtierenden Grossrät:innen zuerst auf und sortiert anschliessend alphabetisch, weicht von dieser Regelung jedoch teilweise ab, insofern dass sie nach den amtierenden Grossrät:innen erst ihre Spitzenkandidierenden auflistet.

```{r tab10, echo=FALSE, message=TRUE, warning=FALSE}
tibble("Partei / Liste" = c("SP (2008)", 
                            "SP (2012-2024)",
                            "Grünes Bündnis",
                            "BastA!",
                            "FDP (2020)",
                            "GLP",
                            "Die Mitte",
                            "SVP",
                            "GRÜNE",
                            "LDP",
                            "FDP (2024)"),
       "Bisherige zuerst (innerhalb von)" = c("Nein", 
                                              "Nein", 
                                              "Ja",
                                              "Ja",
                                              "Ja (Geschlecht)",
                                              "Ja",
                                              "Ja",
                                              "Ja",
                                              "Ja",
                                              "Ja",
                                              "Ja"),
       "Frauen zuerst" = c("Ja", 
                           "Ja", 
                           "Ja",
                           "Ja",
                           "Ja",
                           "Nein",
                           "Nein",
                           "Nein",
                           "Nein",
                           "Nein",
                           "Nein"),
       "Alphabetisch (innerhalb von)" = c("Nein", 
                                          "Ja (Geschlecht)", 
                                          "Ja (Amtsinhaberschaft > Geschlecht)",
                                          "Ja (Amtsinhaberschaft > Geschlecht)",
                                          "Ja (Amtsinhaberschaft > Geschlecht)",
                                          "Nein",
                                          "Ja (Amtsinhaberschaft)",
                                          "Ja (Amtsinhaberschaft)",
                                          "Ja (Amtsinhaberschaft)",
                                          "Ja (Amtsinhaberschaft)",
                                          "Ja (Amtsinhaberschaft)")) %>% 
  kbl("latex", caption = "Listenplatz-Regelungen der Parteien", booktabs = TRUE, linesep = "") %>% 
  kable_styling(latex_options = c("HOLD_position"),
              full_width = TRUE) %>%
  #column_spec(1, width = "4.75cm") %>%
  #column_spec(2, width = "4.25cm") %>%
  column_spec(4, width = "6cm")
```

## Ergebnisse für die SP -- Stimmenanteil

### Basismodell

```{r tab11, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_share

margins(model) %>%
  tidy() %>%
  mutate(id = factor(term, levels = c("genderM", "incumbent", "kreisGrossbasel West", "kreisKleinbasel", "kreisRiehen", "year2024", "year2020", "year2016", "year2012", "list_place"))) %>% 
  arrange(id) %>%
  mutate(`Variable` = case_when(term == "genderM" ~ "Geschlecht = Mann",
                                term == "incumbent" ~ "Bisher = Ja",
                                term == "kreisGrossbasel West" ~ "Grossbasel West",
                                term == "kreisKleinbasel" ~ "Kleinbasel",
                                term == "kreisRiehen" ~ "Riehen",
                                term == "list_place" ~ "Listenrang",
                                term == "year2012" ~ "Jahr = 2012",
                                term == "year2016" ~ "Jahr = 2016",
                                term == "year2020" ~ "Jahr = 2020",
                                term == "year2024" ~ "Jahr = 2024",
                                TRUE ~ term),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Variable`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Marginale Effekte", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>% 
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "4.75cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Heterogenität über die Wahljahre

```{r tab12, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_years_share

margins(model, 
        variables = "list_place", 
        at = list(year = model$xlevels$year)) %>% 
  tidy() %>%
  mutate(id = factor(`at.value`, levels = c("2024", "2020", "2016", "2012"))) %>% 
  arrange(id) %>%
  mutate(`Jahr` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Jahr`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahljahren", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>% 
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Heterogenität über die Wahlkreise

```{r tab13, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_kreis_share

margins(model, 
        variables = "list_place", 
        at = list(kreis = model$xlevels$kreis)) %>% 
  tidy() %>%
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahlkreisen", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Heterogenität über Frauen und Männer

```{r tab14, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_gender_share

margins(model, 
        variables = "list_place", 
        at = list(gender = model$xlevels$gender)) %>% 
  tidy() %>%
  mutate(`Geschlecht` = case_when(`at.value` == "M" ~ "Mann",
                                  `at.value` == "F" ~ "Frau"),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Geschlecht`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Geschlecht", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Heterogenität über SP- und Panaschierstimmen

```{r tab15, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_ownothers_share, variables = "list_place", 
        at = list(kreis = model_sp_ownothers_share$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

```{r tab16, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_own_share, variables = "list_place", 
        at = list(kreis = model_sp_own_share$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs der SP-Stimmen nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

```{r tab17, echo=FALSE, message=TRUE, warning=FALSE}
margins(model_sp_others_share, variables = "list_place", 
        at = list(kreis = model_sp_others_share$xlevels$kreis)) %>% 
  tidy() %>% 
  mutate(`Wahlkreis` = `at.value`,
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte des Listenrangs der Panaschierstimmen nach Wahlkreisen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Weitere erklärende Variablen

```{r tab18, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_sp_weitere_share

margins(model) %>%
  tidy() %>%
  mutate(id = factor(term, levels = c("genderM", "age", "incumbent", "above", "below", "kreisGrossbasel West", "kreisKleinbasel", "kreisRiehen", "year2024", "list_place"))) %>% 
  arrange(id) %>% 
  mutate(`Variable` = case_when(term == "genderM" ~ "Geschlecht = Mann",
                                term == "incumbent" ~ "Bisher = Ja",
                                term == "kreisGrossbasel West" ~ "Grossbasel West",
                                term == "kreisKleinbasel" ~ "Kleinbasel",
                                term == "kreisRiehen" ~ "Riehen",
                                term == "list_place" ~ "Listenrang",
                                term == "year2024" ~ "Jahr = 2024",
                                term == "above" ~ "Oberhalb Bisher = Ja",
                                term == "below" ~ "Unterhalb Bisher = Ja",
                                term == "age" ~ "Alter",
                                TRUE ~ term),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Variable`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekte weiterer erklärender Variablen (Wahljahre 2024 und 2020)", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "4.75cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

### Ergebnisse für weitere Parteien

```{r tab19, echo=FALSE, message=TRUE, warning=FALSE}
model <- model_all_share

margins(model, 
        variables = "list_place", 
        at = list(party = model$xlevels$party)) %>%
  tidy() %>%
  arrange(estimate) %>% 
  mutate(`Wahlkreis` = case_when(`at.value` == "BastA" ~ "BastA!",
                                 `at.value` == "FDP" ~ "FDP",
                                 `at.value` == "GB" ~ "Grünes Bündnis",
                                 `at.value` == "GLP" ~ "GLP",
                                 `at.value` == "GRÜNE" ~ "GRÜNE",
                                 `at.value` == "LDP" ~ "LDP",
                                 `at.value` == "Mitte" ~ "Die Mitte",
                                 `at.value` == "SP" ~ "SP",
                                 `at.value` == "SVP" ~ "SVP"),
         `Marginaler Effekt` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  select(`Wahlkreis`, `Marginaler Effekt`, `Standardfehler`, 
         `p-Wert`, `Signifikanz`) %>% 
  kbl("latex", digits = 3, 
      caption = "Durchschnittliche marginale Effekt nach Parteien", booktabs = TRUE, linesep = "") %>% 
  add_header_above(c(" " = 1, "Zielgrösse: Stimmenanteil (standardisiert)" = 4)) %>%
  kable_styling(latex_options = c("HOLD_position"),
                full_width = FALSE) %>%
  column_spec(1, width = "3cm") %>%
  column_spec(2, width = "4.25cm") %>%
  column_spec(3:4, width = "1.5cm") %>%
  footnote(general = "*** p < 0.01, ** p < 0.05, * p < 0.1.",
           general_title = "Hinweis:", 
           footnote_as_chunk = TRUE)
```

```{r eval=FALSE, include=FALSE}
model <- model_sp_years

model %>%
  tidy() %>% 
  mutate(`Variable` = case_when(term == "incumbentTRUE" ~ "Bisher",
                                term == "genderM" ~ "Mann",
                                term == "list_place" ~ "Listenrang",
                                term == "year2012:list_place" ~ "2012 x Listenrant",
                                term == "year2016:list_place" ~ "2016 x Listenrant",
                                term == "year2020:list_place" ~ "2020 x Listenrant",
                                term == "year2024:list_place" ~ "2024 x Listenrant",
                                TRUE ~ term),
         `Koeffizient` = estimate,
         `Standardfehler` = `std.error`,
         `p-Wert` = `p.value`,
         `Signifikanz` = sapply(`p.value`, add_stars)) %>%
  filter(Variable %in% c("Bisher", "Mann", "Listenrang", 
                         "2012 x Listenrang",
                         "2016 x Listenrang",
                         "2020 x Listenrang",
                         "2024 x Listenrang")) %>% 
  select(`Variable`, `Koeffizient`, `Standardfehler`,
         `p-Wert`, `Signifikanz`) %>% 
  kable("latex", digits = 3, caption = "Regressionsergebnisse") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"))
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Regression Discontinuity

data_final %>% 
  filter(rank_gender %in% 1:4) %>% 
  lm("rank ~ incumbent + year + either + kreis + gender", 
   data = .) %>% 
  tidy() %>% 
  mutate(significance = sapply(p.value, add_stars)) %>%
  kable("latex", digits = 2, caption = "Regression Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = F)

data_final %>% 
  filter(rank_gender %in% 1:4) %>% 
  lm("share_scale ~ incumbent + year + either + kreis + gender", 
   data = .) %>% 
  tidy() %>% 
  mutate(significance = sapply(p.value, add_stars)) %>%
  kable("latex", digits = 2, caption = "Regression Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = F)

data_final %>% 
  mutate(rank_pred = resid(lm(rank ~ kreis*incumbent, 
                                     data = .))) %>% 
  filter(rank_gender %in% 1:4) %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = -rank_pred, 
                 col = gender, shape = incumbent)) +
  geom_smooth(aes(x = list_place, y = -rank_pred),
              method = "lm", se = FALSE) +
  facet_wrap(~ kreis + year)
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Aufbereitete Darstellung Listenrang vs. Stimmenanteil

rank_breaks <- function(x) {
  seq(1, max(x), length.out = 5)
}

share_breaks <- function(x) {
  seq(min(x), max(x), length.out = 5)
}

plot1 <- data_final %>% 
  filter(year == "2020") %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = rank)) +
  geom_smooth(aes(x = list_place, y = rank),
              method = "lm", se = FALSE) +
  scale_x_continuous(breaks = seq(1, 35, 4)) +
  scale_y_reverse(breaks = function(x) rank_breaks(x),
                  labels = function(x) sprintf("%.0f", x)) +
  facet_wrap(~ kreis, scales = "free_y", nrow = 4) +
  labs(x = element_blank(), y = "Rang") +
  theme_minimal()

plot2 <- data_final %>% 
  filter(year == "2020") %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = 100*share)) +
  geom_smooth(aes(x = list_place, y = 100*share),
              method = "lm", se = FALSE) +
  scale_x_continuous(breaks = seq(1, 35, 4)) +
  scale_y_continuous(breaks = function(x) share_breaks(x),
                     labels = function(x) sprintf("%.1f", x)) +
  facet_wrap(~ kreis, scales = "free_y", nrow = 4) +
  labs(x = element_blank(), y = "Stimmenanteil (in %)") +
  theme_minimal()

grid.arrange(plot1, plot2, ncol = 2,
             bottom = "Listenrang")
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Wahrscheinlichkeit, gewählt zu werden

model <- data_final %>% 
  glm("elected ~ incumbent + year + gender + either + kreis*list_place", 
                    data = ., family = binomial)

coef_intercept <- model$coefficients["(Intercept)"]
coef_list <- model$coefficients["list_place"]
coef_gbw_list <- model$coefficients["kreisGrossbasel West:list_place"]
coef_kb_list <- model$coefficients["kreisKleinbasel:list_place"]
coef_r_list <- model$coefficients["kreisRiehen:list_place"]

data_final %>% 
  mutate(prob_gbo = 1/(1 + exp(-(coef_intercept + 
                                    list_place*coef_list))),
         prob_gbw = 1/(1 + exp(-(coef_intercept + 
                                   list_place*coef_list + 
                                   list_place*coef_gbw_list))),
         prob_kb = 1/(1 + exp(-(coef_intercept + 
                                  list_place*coef_list + 
                                  list_place*coef_kb_list))),
         prob_r = 1/(1 + exp(-(coef_intercept + 
                                 list_place*coef_list + 
                                 list_place*coef_r_list)))) %>% 
  ggplot() + 
  geom_line(aes(x = list_place, y = prob_gbo)) +
  #geom_line(aes(x = list_place, y = prob_gbw), col = "red") +
  geom_line(aes(x = list_place, y = prob_kb), col = "blue") +
  geom_line(aes(x = list_place, y = prob_r), col = "green")
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Anschauungsbeipsiel Listenrang vs. Stimmenanteil

plot1 <- data_final %>% 
  filter(year == "2020",
         kreis == "Riehen") %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = rank)) +
  geom_smooth(aes(x = list_place, y = rank),
              method = "lm", se = FALSE) +
  scale_x_continuous(breaks = seq(1, 11, 2)) +
  scale_y_reverse(breaks = seq(1, 11, 2)) +
  labs(x = element_blank(), y = "Rang") +
  theme_minimal()

plot2 <- data_final %>% 
  filter(year == "2020",
         kreis == "Riehen") %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = 100*share)) +
  geom_smooth(aes(x = list_place, y = 100*share),
              method = "lm", se = FALSE) +
  scale_x_continuous(breaks = seq(1, 11, 2)) +
  labs(x = element_blank(), y = "Stimmenanteil (in %)") +
  theme_minimal()

grid.arrange(plot1, plot2, ncol = 1,
             bottom = "Listenrang")
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Der beste Rang je Listenplatz über die Jahre
data_final %>% 
  group_by(kreis, list_place, gender) %>% 
  summarise(rank_min = min(rank)) %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = rank_min, col = gender)) +
  geom_smooth(aes(x = list_place, y = rank_min), method = "lm", se = FALSE) +
  scale_y_reverse() +
  facet_wrap(~ kreis) +
  theme_minimal()

data_final %>% 
  group_by(kreis, list_place, gender) %>% 
  summarise(share_min = min(share)) %>% 
  ggplot() +
  geom_point(aes(x = list_place, y = share_min, col = gender)) +
  geom_smooth(aes(x = list_place, y = share_min), method = "lm", se = FALSE) +
  facet_wrap(~ kreis, scales = "free_y") +
  theme_minimal()
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Kontrafaktischer Wahlergebnisrang
model <- lm("rank ~ kreis*incumbent + year + kreis*gender + kreis*list_place", data = data_final %>% filter(year %in% c("2024", "2020")))

rank_resid <- residuals(model)
rank_pred <- predict(model, newdata = data_final %>% 
                       filter(year %in% c("2024", "2020")) %>% 
                       mutate(list_place = 1))

intercepts <- data_final %>%
  filter(year %in% c("2024", "2020")) %>% 
  group_by(year, kreis) %>%
  summarize(elected_sum = sum(as.numeric(elected)) + 0.5, 
            .groups = "drop")

data_final %>% 
  filter(year %in% c("2024", "2020")) %>% 
  mutate(rank_pred = rank_pred + rank_resid) %>%
  arrange(year, kreis, rank_pred) %>% 
  group_by(year, kreis) %>% 
  mutate(rank_c = rank(rank_pred)) %>%
  ungroup() %>% 
  select(year, kreis, name, gender, rank, rank_c, elected) %>% 
  pivot_longer(cols = c(rank, rank_c),
               names_to = "type",
               values_to = "rank") %>% 
  left_join(intercepts, by = c("year", "kreis")) %>% 
  filter(year == "2024") %>% 
  ggplot() +
  geom_point(aes(x = type, y = rank, group = name, 
                 col = elected)) +
  geom_line(aes(x = type, y = rank, group = name,
                col = elected)) +
  geom_hline(aes(yintercept = elected_sum), col = "red") +
  scale_y_reverse() +
  facet_wrap(~ kreis) +
  theme_minimal()
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Aufschlüsselung der SP- und Panaschierstimmen
data_final_2024_all %>% 
  select(party, kreis, seats, ballot_kreis_list_changed, votes_to_others,
         starts_with("votes_by_"), ballot_kreis_list_extra_changed) %>% 
  filter(party == "SP") %>% 
  group_by(kreis) %>%  
  summarise(seats = mean(seats),
            ballot_kreis_list_changed = mean(ballot_kreis_list_changed),
            ballot_kreis_list_extra_changed = mean(ballot_kreis_list_extra_changed),
            votes_to_others = mean(votes_to_others),
            votes_by_own = sum(votes_by_own),
            votes_by_others = sum(votes_by_others))
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Panaschierstimmen Parteiebene
data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, votes_by_others, starts_with("votes_by_party")) %>% 
  select(-votes_by_party_SP) %>% 
  group_by(kreis) %>% 
  summarise_at(vars(starts_with("votes_by")), ~ sum(., na.rm = TRUE)) %>% 
  mutate_at(vars(starts_with("votes_by_party")), ~ ./votes_by_others) %>% 
  pivot_longer(starts_with("votes_by_party"),
               names_prefix = "votes_by_party_",
               names_to = "party",
               values_to = "votes_share") %>% 
  arrange(kreis, desc(votes_share)) %>% 
  mutate(party = factor(party, levels = unique(party))) %>%
  ggplot() +
  geom_col(aes(x = party, y = votes_share)) +
  facet_wrap(~ kreis)

# Stimmen von den anderen Parteien
data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, votes_by_others, starts_with("votes_by_party")) %>% 
  select(-votes_by_party_SP) %>% 
  pivot_longer(starts_with("votes_by_party"),
               names_prefix = "votes_by_party_",
               names_to = "party",
               values_to = "votes_share") %>%
  arrange(kreis, votes_by_others, votes_share) %>% 
  mutate(kreis = factor(kreis, levels = unique(kreis)),
         name = factor(name, levels = unique(name)),
         party = factor(party, levels = unique(party))) %>% 
  filter(kreis == "Kleinbasel") %>% 
  ggplot() +
  geom_col(aes(x = votes_share, y = name, fill = party))

# Stimmen von den Grünen
data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, votes_by_party_Gruene) %>% 
  arrange(kreis, votes_by_party_Gruene) %>% 
  mutate(name = factor(name, levels = unique(name))) %>% 
  filter(kreis == "Kleinbasel") %>% 
  ggplot() +
  geom_col(aes(x = votes_by_party_Gruene, y = name)) +
  facet_wrap(~ kreis)

# Stimmen von der BastA!
data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, votes_by_party_BastA) %>% 
  arrange(kreis, votes_by_party_BastA) %>% 
  mutate(name = factor(name, levels = unique(name))) %>% 
  filter(kreis == "Kleinbasel") %>% 
  ggplot() +
  geom_col(aes(x = votes_by_party_BastA, y = name)) +
  facet_wrap(~ kreis)

# Stimmenanteile von den anderen Parteien
data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, votes_by_others, starts_with("votes_by_party")) %>% 
  mutate(votes_by_others_alt = votes_by_others-votes_by_party_ohne) %>% 
  select(-votes_by_party_SP, -votes_by_party_ohne) %>% 
  mutate_at(vars(starts_with("votes_by_party")), ~ ./votes_by_others_alt) %>%
  arrange(kreis, votes_by_party_Gruene) %>% 
  pivot_longer(starts_with("votes_by_party"),
               names_prefix = "votes_by_party_",
               names_to = "party",
               values_to = "votes_share") %>%
  filter(kreis == "Kleinbasel") %>%
  mutate(name = factor(name, levels = unique(name)),
         party = factor(party, levels = c("FDP", "LDP", "SVP", "EVP", "EDU",
                                          "PdA", "VA", "PBkW", "FSSK", "KUSS",
                                          "Mitte", "GLP", "BastA", "Gruene"))) %>%
  ggplot() +
  geom_col(aes(x = votes_share, y = name, fill = party))
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Cutoff-Stellen
data_cutoff <- data_final_2024_all %>% 
  select(party, kreis, seats, ballot_kreis_list_changed, votes_to_others,
         starts_with("votes_by_"), ballot_kreis_list_extra_changed) %>% 
  filter(party == "SP") %>% 
  group_by(kreis) %>%  
  summarise(seats = mean(seats),
            ballot_kreis_list_changed = mean(ballot_kreis_list_changed),
            ballot_kreis_list_extra_changed = mean(ballot_kreis_list_extra_changed),
            votes_to_others = mean(votes_to_others),
            votes_by_own = sum(votes_by_own),
            votes_by_others = sum(votes_by_others)) %>% 
  mutate(cutoff = round(votes_by_own/seats)) %>% 
  select(kreis, cutoff)

data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, incumbent, votes_by_own) %>% 
  left_join(data_cutoff, by = "kreis") %>%
  arrange(kreis, votes_by_own) %>% 
  mutate(name = factor(name, levels = unique(name))) %>% 
  filter(kreis == "Kleinbasel") %>% 
  ggplot() +
  geom_col(aes(x = votes_by_own, y = name, fill = incumbent)) +
  geom_vline(aes(xintercept = cutoff), col = "red")

data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, gender, incumbent, votes_by_own) %>% 
  left_join(data_cutoff, by = "kreis") %>%
  arrange(kreis, votes_by_own) %>% 
  mutate(name = factor(name, levels = unique(name))) %>% 
  ggplot() + 
  geom_point(aes(x = list_place, y = votes_by_own, col = gender, shape = incumbent)) +
  geom_hline(aes(yintercept = cutoff), col = "red") +
  facet_wrap(~ kreis)

data_final_2024_all %>% 
  filter(party == "SP") %>% 
  select(kreis, list_place, name, gender, incumbent, votes_by_own) %>% 
  left_join(data_cutoff, by = "kreis") %>%
  mutate(dist = votes_by_own - cutoff) %>% 
  arrange(kreis, desc(list_place)) %>% 
  mutate(name = factor(name, levels = unique(name))) %>% 
  filter(kreis == "Grossbasel West") %>% 
  ggplot() + 
  geom_col(aes(x = dist, y = name, fill = incumbent))
```
